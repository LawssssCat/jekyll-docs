(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var lazyload = require('lazyload');
var tocSettings = window.VARIABLES.toc;

lazyload.onload(function () {
  var _require = require('lib/toc'),
      Toc = _require.Toc;

  var toc = new Toc({
    headerSelectors: tocSettings.selectors
  });
  toc.init();
});

},{"lazyload":undefined,"lib/toc":3}],2:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Stack = function () {
  function Stack(arr) {
    _classCallCheck(this, Stack);

    this.arr = arr || [];
  }

  _createClass(Stack, [{
    key: "size",
    value: function size() {
      return this.arr.length;
    }
  }, {
    key: "pop",
    value: function pop() {
      return this.arr.pop();
    }
  }, {
    key: "push",
    value: function push(item) {
      return this.arr.push(item);
    }
  }, {
    key: "first",
    value: function first() {
      if (this.arr.length > 0) {
        return this.arr[0];
      }
    }
  }, {
    key: "last",
    value: function last() {
      if (this.arr.length > 0) {
        return this.arr[this.arr.length - 1];
      }
    }
  }]);

  return Stack;
}();

module.exports = {
  Stack: Stack
};

},{}],3:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('lib/stack'),
    Stack = _require.Stack;

var TOOL = require('tool-box');
var logger = require('logger');

function getHeadingDomlevel(headingDom) {
  // h1 => 1, h2 => 2 , ...
  var str = headingDom.tagName.slice(1);
  return parseInt(str);
}

/*
<ol>
  <li> <!-- h1 -->
    <a>h1</a>
    <ol>
      <li> <!-- h2 -->
        <a2>h2</a2>
      </li>
      <li> <!-- h2 -->
        <a2>h2</a2>
      </li>
      <li> <!-- h2 -->
        <a2>h2</a2>
      </li>
      <li> <!-- h2 -->
        <a2>h2</a2>
      </li>
    </ol>
  </li>
  <li> <!-- h1 -->
    <a>h1</a>
  </li>
  <li> <!-- h1 ! -->
    <ol>
      <li> <!-- h2 ! -->
        <ol>
          <li> <!-- h3 -->
            <a>h3</a>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li> <!-- h1 ! -->
    <ol>
      <li> <!-- h2 -->
        <a2>h2</a2>
      </li>
      <li> <!-- h2 -->
        <a2>h2</a2>
      </li>
      <li> <!-- h2 -->
        <a2>h2</a2>
      </li>
      <li> <!-- h2 -->
        <a2>h2</a2>
      </li>
    </ol>
  </li>
</ol>
*/
function generateTocDOM(headers, headersLevel, topLevel) {
  var tag = 'ol',
      tocDom = function () {
    var rootNode = document.createElement(tag); // result
    rootNode.classList.add('root-node');
    return rootNode;
  }(),

  // stack
  stackDOM = new Stack([tocDom]),
      headersDOMlist = []; // save for later use

  // create header dom one by one
  var index = 0,
      preLevel = topLevel;
  while (index < headers.length) {
    var preDOM = stackDOM.last(),
        curLevel = headersLevel[index];
    if (preLevel < curLevel) // go deeper
      {
        var li = document.createElement('li'),
            ol = document.createElement(tag);
        li.appendChild(ol);
        preDOM.appendChild(li);
        preLevel++;
        stackDOM.push(ol);
      } else if (preLevel > curLevel) // too deep
      {
        preLevel--;
        stackDOM.pop();
      } else // preLevel==curLevel
      {
        if (preDOM.tagName.toLowerCase() != tag) {
          // a => ol
          var _ol = document.createElement(tag);
          preDOM.appendChild(_ol);
          preDOM = _ol;
          stackDOM.pop();
          stackDOM.push(_ol);
        }
        var header = headers[index],
            _li = document.createElement('li'),
            a = document.createElement('a');
        a.href = '#' + header.id;
        a.textContent = header.textContent;
        _li.appendChild(a);
        _li.classList.add('toc-h' + (curLevel + 1));
        preDOM.appendChild(_li); // top is 'li' not 'ol'
        preLevel++;
        stackDOM.push(_li);
        index++;
        headersDOMlist.push(_li); // save for later use
      }
  }
  return {
    tocDom: tocDom,
    headersDOMlist: headersDOMlist
  };
}

var Toc = function () {
  function Toc() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Toc);

    this.config = {};
    this.config.contentSelector = options.contentSelector || '.js-article-content';
    this.config.tocSelector = options.tocSelector || '.js-toc-root';
    this.config.headerSelectors = options.headerSelectors || 'h1,h2,h3';
    this.config.headerIgnoreAttr = options.headerIgnoreAttr || 'toc-header-ignore';
  }

  _createClass(Toc, [{
    key: 'init',
    value: function init() {
      var _this = this;

      // assamble
      this.toc = window.document.querySelector(this.config.tocSelector) || TOOL.throwError('can\'t find ' + this.config.tocSelector);
      this.content = window.document.querySelector(this.config.contentSelector) || TOOL.throwError('can\'t find ' + this.config.contentSelector);
      this.headers = Array.from(this.content.querySelectorAll(this.config.headerSelectors)).filter(function (header) {
        // has id
        var id = header.getAttribute('id');
        // no ignore flag
        var flagIgnore = header.hasAttribute(_this.config.headerIgnoreAttr);
        return id != null && !flagIgnore;
      });
      if (this.headers.length == 0) {
        logger.info('toc', this.toc.innerHTML = 'no headings...');
        return;
      }

      // level
      this.headersLevel = this.headers.map(function (header) {
        return getHeadingDomlevel(header);
      });
      this.topLevel = Math.min.apply(Math, _toConsumableArray(this.headersLevel)); // save for later use

      // rander
      this.rander();

      // listener
      var updateTocFlag = false;
      window.addEventListener('headingsActiveUpdate', function (e) {
        // sevent customEvent "headingsActiveUpdate"
        logger.isDebug() && logger.debug('toc.js', e);
        updateTocFlag = true;
        var handingDomActiveList = e.detail;
        _this.updateToc(handingDomActiveList);
      });
      var intervalId = setInterval(function () {
        if (!updateTocFlag) {
          window.dispatchEvent(new Event('require headingsActiveUpdate'));
        } else {
          if (intervalId) {
            clearInterval(intervalId);
          }
        }
      }, 100);
    }
  }, {
    key: 'rander',
    value: function rander() {
      var _generateTocDOM = generateTocDOM(this.headers, this.headersLevel, this.topLevel),
          tocDom = _generateTocDOM.tocDom,
          headersDOMlist = _generateTocDOM.headersDOMlist;

      this.headersDOMlist = headersDOMlist;
      this.headersDOMlist.forEach(function (dom) {
        var a = dom.querySelector('a');
        if (a) {
          a.addEventListener('click', function (e) {
            e.preventDefault();
            var href = a.getAttribute('href');
            TOOL.historyPushHash(href);
          });
        }
      });
      this.toc.appendChild(tocDom);
    }
  }, {
    key: 'updateToc',
    value: function updateToc(handingDomActiveList) {
      // if(this.disable()) return; // if no header or display=none, don't update // 2022-07-03 if toc disable, return directly on init.
      this.updateActive(handingDomActiveList);
      this.updateTocScroll();
    }
  }, {
    key: 'updateTocScroll',
    value: function updateTocScroll() {
      var _this2 = this;

      // if toc overflow, top active header at the top of toc scroll
      if (TOOL.isOverflowY(this.toc)) {
        var activeList = this.headersDOMlist.filter(function (dom) {
          return dom.classList.contains(_this2.activeClass);
        });
        if (activeList && activeList.length > 0) {
          var topActive = void 0,
              lowestActive = void 0,
              topTop = void 0,
              lowestTop = void 0;
          if (activeList.length == 1) {
            topActive = lowestActive = activeList[0];
            topTop = lowestTop = TOOL.positionRelative(topActive, this.toc).top;
          } else {
            topActive = activeList[0];
            lowestActive = activeList[activeList.length - 1];
            topTop = TOOL.positionRelative(topActive, this.toc).top;
            lowestTop = TOOL.positionRelative(lowestActive, this.toc).top;
          }
          var scrollHeight = this.toc.clientHeight,
              activeHeight = lowestTop - topTop;
          var scrollTop = void 0;
          if (scrollHeight > activeHeight) {
            scrollTop = topTop;
          } else {
            scrollTop = lowestTop - scrollHeight;
          }
          this.toc.scroll({
            top: scrollTop,
            behavior: 'smooth'
          });
        }
      }
    }
  }, {
    key: 'updateActive',
    value: function updateActive(handingDomActiveList) {
      var _this3 = this;

      this.headersDOMlist.forEach(function (dom) {
        dom.classList.remove('active');
        dom.classList.remove('through');
      });
      if (handingDomActiveList && handingDomActiveList.length > 0) {
        var selector = handingDomActiveList.map(function (headingDom) {
          return 'a[href="#' + headingDom.id + '"]';
        }).join(',');
        var activeHeaderLevel = [];
        var activeHeaderDomList = this.headersDOMlist.filter(function (dom, index) {
          var flag = dom.querySelectorAll(selector).length > 0;
          if (flag) {
            var headerLevel = _this3.headersLevel[index];
            activeHeaderLevel.push(headerLevel);
          }
          return flag;
        });
        // active
        activeHeaderDomList.forEach(function (dom) {
          dom.classList.add('active');
        });
        // through
        var index = 0,
            activeIndex = 0;
        for (; activeIndex < activeHeaderDomList.length;) {
          var headerDom = this.headersDOMlist[index],
              headerLevel = this.headersLevel[index];
          index++;
          var activeHeaderDom = activeHeaderDomList[activeIndex],
              activeLevel = activeHeaderLevel[activeIndex];
          if (headerDom == activeHeaderDom) {
            activeIndex++;
          }
          if (headerLevel == activeLevel && headerDom != activeHeaderDom) {
            headerDom.classList.add('through');
          }
        }
      }
    }
  }]);

  return Toc;
}();

module.exports = {
  Toc: Toc
};

},{"lib/stack":2,"logger":undefined,"tool-box":undefined}]},{},[1]);
